---
---

<div class="contour-canvas-wrapper">
  <canvas id="contour-canvas"></canvas>
</div>

<script>
  import * as PerlinNoise from '@chriscourses/perlin-noise';

  let canvas: HTMLCanvasElement | null = null;
  let ctx: CanvasRenderingContext2D | null = null;
  let animationFrameId: number = 0;
  let resizeObserver: ResizeObserver | null = null;
  let resizeTimeout: ReturnType<typeof setTimeout> | null = null;
  let isInitialized = false;
  let isAnimating = false;

  const thresholdIncrement = 6;
  const thickLineThresholdMultiple = 3;
  const res = 10;
  const baseZOffset = 0.00005;
  const lineColor = '#71717a30';
  const RESIZE_DEBOUNCE_MS = 150;
  const MIN_CANVAS_SIZE = 100;
  const MAX_DEVICE_PIXEL_RATIO = 3;

  let currentThreshold = 0;
  let cols = 0;
  let rows = 0;
  let zOffset = 0;
  let zBoostValues: number[][] = [];
  let noiseMin = 100;
  let noiseMax = 0;
  let inputValues: number[][] = [];
  let previousWidth = 0;
  let previousHeight = 0;

  let mousePos = { x: -99, y: -99 };

  function debounce(func: Function, wait: number) {
    return function executedFunction(...args: any[]) {
      const later = () => {
        if (resizeTimeout) clearTimeout(resizeTimeout);
        func(...args);
      };
      if (resizeTimeout) clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(later, wait);
    };
  }

  function cleanup() {
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = 0;
    }

    if (resizeObserver) {
      resizeObserver.disconnect();
      resizeObserver = null;
    }

    if (resizeTimeout) {
      clearTimeout(resizeTimeout);
      resizeTimeout = null;
    }

    isAnimating = false;
    isInitialized = false;
  }

  function setupCanvas() {
    cleanup();

    canvas = document.getElementById('contour-canvas') as HTMLCanvasElement;
    if (!canvas) {
      console.warn('ContourCanvas: Canvas element not found');
      return false;
    }

    const canvasCtx = canvas.getContext('2d', {
      alpha: true,
      desynchronized: true
    });

    if (!canvasCtx) {
      console.warn('ContourCanvas: Could not get 2D context');
      return false;
    }

    ctx = canvasCtx;

    if (!initializeCanvasSize()) {
      console.warn('ContourCanvas: Failed to initialize canvas size');
      return false;
    }

    setupResizeObserver();
    setupMouseEvents();

    isInitialized = true;
    return true;
  }

  function setupResizeObserver() {
    if (!canvas) return;

    const handleResize = debounce(() => {
      if (canvas && isInitialized) {
        const rect = canvas.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0) {
          const hasChanged = Math.abs(rect.width - previousWidth) > 1 ||
                            Math.abs(rect.height - previousHeight) > 1;

          if (hasChanged) {
            resizeCanvas();
          }
        }
      }
    }, RESIZE_DEBOUNCE_MS);

    if (typeof ResizeObserver !== 'undefined') {
      resizeObserver = new ResizeObserver((entries) => {
        for (const entry of entries) {
          if (entry.target === canvas) {
            handleResize();
          }
        }
      });

      resizeObserver.observe(canvas);
    } else {
      if (typeof window !== 'undefined') {
        window.addEventListener('resize', handleResize);
        window.addEventListener('orientationchange', () => {
          setTimeout(handleResize, 300);
        });
      }
    }
  }

  function setupMouseEvents() {
    if (!canvas) return;

    canvas.addEventListener('mousemove', (e) => {
      if (!canvas) return;
      const rect = canvas.getBoundingClientRect();
      mousePos = {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
    });

    canvas.addEventListener('mouseleave', () => {
      mousePos = { x: -99, y: -99 };
    });
  }

  function initializeCanvasSize(): boolean {
    if (!canvas || !ctx) return false;

    requestAnimationFrame(() => {
      if (!canvas) return;
      const parent = canvas.parentElement;
      if (!parent) return;

      const parentRect = parent.getBoundingClientRect();
      const width = Math.max(parentRect.width, MIN_CANVAS_SIZE);
      const height = Math.max(parentRect.height, MIN_CANVAS_SIZE);

      if (width < MIN_CANVAS_SIZE || height < MIN_CANVAS_SIZE) {
        console.warn('ContourCanvas: Canvas dimensions too small', { width, height });
        return;
      }

      setCanvasDimensions(width, height);
    });

    return true;
  }

  function resizeCanvas() {
    if (!canvas || !ctx) return;

    const wasAnimating = isAnimating;
    if (wasAnimating && animationFrameId) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = 0;
      isAnimating = false;
    }

    requestAnimationFrame(() => {
      if (!canvas || !ctx) return;

      const parent = canvas.parentElement;
      if (!parent) return;

      const parentRect = parent.getBoundingClientRect();
      const width = Math.max(parentRect.width, MIN_CANVAS_SIZE);
      const height = Math.max(parentRect.height, MIN_CANVAS_SIZE);

      if (width < MIN_CANVAS_SIZE || height < MIN_CANVAS_SIZE) {
        return;
      }

      setCanvasDimensions(width, height);

      if (wasAnimating) {
        startAnimation();
      }
    });
  }

  function setCanvasDimensions(width: number, height: number) {
    if (!canvas || !ctx) return;

    const dpr = Math.min(window.devicePixelRatio || 1, MAX_DEVICE_PIXEL_RATIO);

    const scaledWidth = Math.ceil(width * dpr);
    const scaledHeight = Math.ceil(height * dpr);

    if (canvas.width === scaledWidth && canvas.height === scaledHeight) {
      return;
    }

    canvas.width = scaledWidth;
    canvas.height = scaledHeight;
    canvas.style.width = `${Math.ceil(width)}px`;
    canvas.style.height = `${Math.ceil(height)}px`;

    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);

    previousWidth = width;
    previousHeight = height;

    initializeGrid(width, height);
  }

  function initializeGrid(width: number, height: number) {
    const logicalWidth = width;
    const logicalHeight = height;

    cols = Math.floor(logicalWidth / res) + 1;
    rows = Math.floor(logicalHeight / res) + 1;

    zBoostValues = [];
    inputValues = [];

    for (let y = 0; y < rows; y++) {
      zBoostValues[y] = [];
      inputValues[y] = [];
      for (let x = 0; x <= cols; x++) {
        zBoostValues[y][x] = 0;
        inputValues[y][x] = 0;
      }
    }
  }

  function startAnimation() {
    if (isAnimating) return;
    isAnimating = true;
    animate();
  }

  function stopAnimation() {
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = 0;
    }
    isAnimating = false;
  }

  function animate() {
    if (!ctx || !canvas || !isAnimating) {
      stopAnimation();
      return;
    }

    animationFrameId = requestAnimationFrame(() => animate());

    if (cols === 0 || rows === 0) {
      return;
    }

    try {
      mouseOffset();

      const canvasWidth = canvas.width;
      const canvasHeight = canvas.height;

      if (canvasWidth > 0 && canvasHeight > 0) {
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      }

      zOffset += baseZOffset;
      generateNoise();

      const roundedNoiseMin = Math.floor(noiseMin / thresholdIncrement) * thresholdIncrement;
      const roundedNoiseMax = Math.ceil(noiseMax / thresholdIncrement) * thresholdIncrement;

      for (let threshold = roundedNoiseMin; threshold < roundedNoiseMax; threshold += thresholdIncrement) {
        currentThreshold = threshold;
        renderAtThreshold();
      }

      noiseMin = 100;
      noiseMax = 0;
    } catch (error) {
      console.error('ContourCanvas: Animation error', error);
      stopAnimation();
    }
  }

  function mouseOffset() {
    const x = Math.floor(mousePos.x / res);
    const y = Math.floor(mousePos.y / res);

    if (!inputValues[y] || inputValues[y][x] === undefined) return;

    const incrementValue = 0.0025;
    const radius = 5;

    for (let i = -radius; i <= radius; i++) {
      for (let j = -radius; j <= radius; j++) {
        const distanceSquared = i * i + j * j;
        const radiusSquared = radius * radius;

        if (distanceSquared <= radiusSquared && zBoostValues[y + i]?.[x + j] !== undefined) {
          zBoostValues[y + i][x + j] += incrementValue * (1 - distanceSquared / radiusSquared);
        }
      }
    }
  }

  function generateNoise() {
    for (let y = 0; y < rows; y++) {
      inputValues[y] = [];
      for (let x = 0; x <= cols; x++) {
        inputValues[y][x] = PerlinNoise.noise(x * 0.02, y * 0.02, zOffset + (zBoostValues[y]?.[x] || 0)) * 100;
        if (inputValues[y][x] < noiseMin) noiseMin = inputValues[y][x];
        if (inputValues[y][x] > noiseMax) noiseMax = inputValues[y][x];
        if (zBoostValues[y]?.[x] > 0) {
          zBoostValues[y][x] *= 0.99;
        }
      }
    }
  }

  function renderAtThreshold() {
    if (!ctx) return;

    ctx.beginPath();
    ctx.strokeStyle = lineColor;
    ctx.lineWidth = currentThreshold % (thresholdIncrement * thickLineThresholdMultiple) === 0 ? 2 : 1;

    for (let y = 0; y < inputValues.length - 1; y++) {
      for (let x = 0; x < inputValues[y].length - 1; x++) {
        if (inputValues[y][x] > currentThreshold && inputValues[y][x + 1] > currentThreshold &&
            inputValues[y + 1][x + 1] > currentThreshold && inputValues[y + 1][x] > currentThreshold) continue;
        if (inputValues[y][x] < currentThreshold && inputValues[y][x + 1] < currentThreshold &&
            inputValues[y + 1][x + 1] < currentThreshold && inputValues[y + 1][x] < currentThreshold) continue;

        const gridValue = binaryToType(
          inputValues[y][x] > currentThreshold ? 1 : 0,
          inputValues[y][x + 1] > currentThreshold ? 1 : 0,
          inputValues[y + 1][x + 1] > currentThreshold ? 1 : 0,
          inputValues[y + 1][x] > currentThreshold ? 1 : 0
        );

        placeLines(gridValue, x, y);
      }
    }
    ctx.stroke();
  }

  function placeLines(gridValue: number, x: number, y: number) {
    if (!ctx) return;

    const nw = inputValues[y][x];
    const ne = inputValues[y][x + 1];
    const se = inputValues[y + 1][x + 1];
    const sw = inputValues[y + 1][x];

    switch (gridValue) {
      case 1:
      case 14:
        line(
          [x * res, y * res + res * linInterpolate(nw, sw)],
          [x * res + res * linInterpolate(sw, se), y * res + res]
        );
        break;
      case 2:
      case 13:
        line(
          [x * res + res, y * res + res * linInterpolate(ne, se)],
          [x * res + res * linInterpolate(sw, se), y * res + res]
        );
        break;
      case 3:
      case 12:
        line(
          [x * res, y * res + res * linInterpolate(nw, sw)],
          [x * res + res, y * res + res * linInterpolate(ne, se)]
        );
        break;
      case 11:
      case 4:
        line(
          [x * res + res * linInterpolate(nw, ne), y * res],
          [x * res + res, y * res + res * linInterpolate(ne, se)]
        );
        break;
      case 5:
        line(
          [x * res, y * res + res * linInterpolate(nw, sw)],
          [x * res + res * linInterpolate(nw, ne), y * res]
        );
        line(
          [x * res + res * linInterpolate(sw, se), y * res + res],
          [x * res + res, y * res + res * linInterpolate(ne, se)]
        );
        break;
      case 6:
      case 9:
        line(
          [x * res + res * linInterpolate(sw, se), y * res + res],
          [x * res + res * linInterpolate(nw, ne), y * res]
        );
        break;
      case 7:
      case 8:
        line(
          [x * res, y * res + res * linInterpolate(nw, sw)],
          [x * res + res * linInterpolate(nw, ne), y * res]
        );
        break;
      case 10:
        line(
          [x * res + res * linInterpolate(nw, ne), y * res],
          [x * res + res, y * res + res * linInterpolate(ne, se)]
        );
        line(
          [x * res + res * linInterpolate(sw, se), y * res + res],
          [x * res, y * res + res * linInterpolate(nw, sw)]
        );
        break;
    }
  }

  function line(from: number[], to: number[]) {
    if (!ctx) return;
    ctx.moveTo(from[0], from[1]);
    ctx.lineTo(to[0], to[1]);
  }

  function linInterpolate(x0: number, x1: number, y0 = 0, y1 = 1) {
    if (x0 === x1) return 0;
    return y0 + ((y1 - y0) * (currentThreshold - x0)) / (x1 - x0);
  }

  function binaryToType(nw: number, ne: number, se: number, sw: number) {
    const a = [nw, ne, se, sw];
    return a.reduce((res: number, x: number) => (res << 1) | x);
  }

  function initialize() {
    requestAnimationFrame(() => {
      const success = setupCanvas();
      if (success) {
        setTimeout(() => {
          if (isInitialized) {
            startAnimation();
          }
        }, 100);
      }
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initialize);
  } else {
    initialize();
  }

  document.addEventListener('astro:before-swap', cleanup);
  document.addEventListener('astro:page-load', initialize);

  if ('visibilityState' in document) {
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        stopAnimation();
      } else if (isInitialized && !isAnimating) {
        startAnimation();
      }
    });
  }
</script>

<style>
  .contour-canvas-wrapper {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    pointer-events: auto;
    z-index: 0;
    overflow: hidden;
    contain: layout style paint;
    isolation: isolate;
  }

  #contour-canvas {
    width: 100%;
    height: 100%;
    display: block;
    touch-action: none;
    -webkit-tap-highlight-color: transparent;
    position: absolute;
    top: 0;
    left: 0;
    object-fit: cover;
  }

  @media (max-width: 768px) {
    .contour-canvas-wrapper {
      will-change: auto;
    }
  }
</style>
