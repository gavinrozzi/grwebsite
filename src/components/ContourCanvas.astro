---
---

<div class="contour-canvas-wrapper">
  <canvas id="contour-canvas"></canvas>
</div>

<script>
  import * as PerlinNoise from '@chriscourses/perlin-noise';

  let canvas: HTMLCanvasElement | null;
  let ctx: CanvasRenderingContext2D | null;
  let animationFrameId: number;

  const thresholdIncrement = 6;
  const thickLineThresholdMultiple = 3;
  const res = 10;
  const baseZOffset = 0.00005;
  const lineColor = '#71717a30';

  let currentThreshold = 0;
  let cols = 0;
  let rows = 0;
  let zOffset = 0;
  let zBoostValues: number[][] = [];
  let noiseMin = 100;
  let noiseMax = 0;
  let inputValues: number[][] = [];

  let mousePos = { x: -99, y: -99 };

  function setupCanvas() {
    canvas = document.getElementById('contour-canvas') as HTMLCanvasElement;
    if (!canvas) return;

    const canvasCtx = canvas.getContext('2d');
    if (!canvasCtx) return;

    ctx = canvasCtx;
    canvasSize();

    window.addEventListener('resize', () => {
      canvasSize();
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas!.getBoundingClientRect();
      mousePos = {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
    });

    canvas.addEventListener('mouseleave', () => {
      mousePos = { x: -99, y: -99 };
    });
  }

  function canvasSize() {
    if (!canvas || !ctx) return;

    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * window.devicePixelRatio;
    canvas.height = rect.height * window.devicePixelRatio;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';

    cols = Math.floor(canvas.width / res) + 1;
    rows = Math.floor(canvas.height / res) + 1;

    zBoostValues = [];
    for (let y = 0; y < rows; y++) {
      zBoostValues[y] = [];
      for (let x = 0; x <= cols; x++) {
        zBoostValues[y][x] = 0;
      }
    }
  }

  function animate() {
    if (!ctx || !canvas) return;

    animationFrameId = requestAnimationFrame(() => animate());

    mouseOffset();
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    zOffset += baseZOffset;
    generateNoise();

    const roundedNoiseMin = Math.floor(noiseMin / thresholdIncrement) * thresholdIncrement;
    const roundedNoiseMax = Math.ceil(noiseMax / thresholdIncrement) * thresholdIncrement;

    for (let threshold = roundedNoiseMin; threshold < roundedNoiseMax; threshold += thresholdIncrement) {
      currentThreshold = threshold;
      renderAtThreshold();
    }

    noiseMin = 100;
    noiseMax = 0;
  }

  function mouseOffset() {
    const x = Math.floor(mousePos.x / res);
    const y = Math.floor(mousePos.y / res);

    if (!inputValues[y] || inputValues[y][x] === undefined) return;

    const incrementValue = 0.0025;
    const radius = 5;

    for (let i = -radius; i <= radius; i++) {
      for (let j = -radius; j <= radius; j++) {
        const distanceSquared = i * i + j * j;
        const radiusSquared = radius * radius;

        if (distanceSquared <= radiusSquared && zBoostValues[y + i]?.[x + j] !== undefined) {
          zBoostValues[y + i][x + j] += incrementValue * (1 - distanceSquared / radiusSquared);
        }
      }
    }
  }

  function generateNoise() {
    for (let y = 0; y < rows; y++) {
      inputValues[y] = [];
      for (let x = 0; x <= cols; x++) {
        inputValues[y][x] = PerlinNoise.noise(x * 0.02, y * 0.02, zOffset + (zBoostValues[y]?.[x] || 0)) * 100;
        if (inputValues[y][x] < noiseMin) noiseMin = inputValues[y][x];
        if (inputValues[y][x] > noiseMax) noiseMax = inputValues[y][x];
        if (zBoostValues[y]?.[x] > 0) {
          zBoostValues[y][x] *= 0.99;
        }
      }
    }
  }

  function renderAtThreshold() {
    if (!ctx) return;

    ctx.beginPath();
    ctx.strokeStyle = lineColor;
    ctx.lineWidth = currentThreshold % (thresholdIncrement * thickLineThresholdMultiple) === 0 ? 2 : 1;

    for (let y = 0; y < inputValues.length - 1; y++) {
      for (let x = 0; x < inputValues[y].length - 1; x++) {
        if (inputValues[y][x] > currentThreshold && inputValues[y][x + 1] > currentThreshold &&
            inputValues[y + 1][x + 1] > currentThreshold && inputValues[y + 1][x] > currentThreshold) continue;
        if (inputValues[y][x] < currentThreshold && inputValues[y][x + 1] < currentThreshold &&
            inputValues[y + 1][x + 1] < currentThreshold && inputValues[y + 1][x] < currentThreshold) continue;

        const gridValue = binaryToType(
          inputValues[y][x] > currentThreshold ? 1 : 0,
          inputValues[y][x + 1] > currentThreshold ? 1 : 0,
          inputValues[y + 1][x + 1] > currentThreshold ? 1 : 0,
          inputValues[y + 1][x] > currentThreshold ? 1 : 0
        );

        placeLines(gridValue, x, y);
      }
    }
    ctx.stroke();
  }

  function placeLines(gridValue: number, x: number, y: number) {
    if (!ctx) return;

    const nw = inputValues[y][x];
    const ne = inputValues[y][x + 1];
    const se = inputValues[y + 1][x + 1];
    const sw = inputValues[y + 1][x];

    switch (gridValue) {
      case 1:
      case 14:
        line(
          [x * res, y * res + res * linInterpolate(nw, sw)],
          [x * res + res * linInterpolate(sw, se), y * res + res]
        );
        break;
      case 2:
      case 13:
        line(
          [x * res + res, y * res + res * linInterpolate(ne, se)],
          [x * res + res * linInterpolate(sw, se), y * res + res]
        );
        break;
      case 3:
      case 12:
        line(
          [x * res, y * res + res * linInterpolate(nw, sw)],
          [x * res + res, y * res + res * linInterpolate(ne, se)]
        );
        break;
      case 11:
      case 4:
        line(
          [x * res + res * linInterpolate(nw, ne), y * res],
          [x * res + res, y * res + res * linInterpolate(ne, se)]
        );
        break;
      case 5:
        line(
          [x * res, y * res + res * linInterpolate(nw, sw)],
          [x * res + res * linInterpolate(nw, ne), y * res]
        );
        line(
          [x * res + res * linInterpolate(sw, se), y * res + res],
          [x * res + res, y * res + res * linInterpolate(ne, se)]
        );
        break;
      case 6:
      case 9:
        line(
          [x * res + res * linInterpolate(sw, se), y * res + res],
          [x * res + res * linInterpolate(nw, ne), y * res]
        );
        break;
      case 7:
      case 8:
        line(
          [x * res, y * res + res * linInterpolate(nw, sw)],
          [x * res + res * linInterpolate(nw, ne), y * res]
        );
        break;
      case 10:
        line(
          [x * res + res * linInterpolate(nw, ne), y * res],
          [x * res + res, y * res + res * linInterpolate(ne, se)]
        );
        line(
          [x * res + res * linInterpolate(sw, se), y * res + res],
          [x * res, y * res + res * linInterpolate(nw, sw)]
        );
        break;
    }
  }

  function line(from: number[], to: number[]) {
    if (!ctx) return;
    ctx.moveTo(from[0], from[1]);
    ctx.lineTo(to[0], to[1]);
  }

  function linInterpolate(x0: number, x1: number, y0 = 0, y1 = 1) {
    if (x0 === x1) return 0;
    return y0 + ((y1 - y0) * (currentThreshold - x0)) / (x1 - x0);
  }

  function binaryToType(nw: number, ne: number, se: number, sw: number) {
    const a = [nw, ne, se, sw];
    return a.reduce((res: number, x: number) => (res << 1) | x);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      setupCanvas();
      animate();
    });
  } else {
    setupCanvas();
    animate();
  }

  document.addEventListener('astro:before-swap', () => {
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
    }
  });
</script>

<style>
  .contour-canvas-wrapper {
    position: absolute;
    inset: 0;
    pointer-events: auto;
    z-index: 0;
  }

  #contour-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
</style>
